---
title: C++ 코드의 Assembly 분석
date: 2026-02-01 01:00:00 +0900
categories: [C++, Assembly]
tags: [c++, assembly]
description: C++ 코드의 Assembly 분석
---


## 1. if 문

아래 if문의 assembly를 분석해보자.
```cpp
int a = 0;
int b = 0;
int c = 0;

int x = 0;
if (a == 10 && b == 20 && c == 35)
{
    x = 1000;
}
x = 500;
```

Assembly
```cpp
if (a == 10 && b == 20 && c == 35)
0x01001A01  cmp         dword ptr [a],0Ah            // a와 10을 비교함
0x01001A05  jne         main+5Ah (01001A1Ah)         // Jump if Not Equal. 같지 않으면 0x01001A1A 주소로 jump 함
0x01001A07  cmp         dword ptr [b],14h            // b와 20을 비교함
0x01001A0B  jne         main+5Ah (01001A1Ah)         // 같지 않으면 0x01001A1A 주소로 jump함
0x01001A0D  cmp         dword ptr [c],23h            // c와 35를 비교함
0x01001A11  jne         main+5Ah (01001A1Ah)         // 같지 않으면 0x01001A1A 주소로 jump함
{
    x = 1000;
0x01001A13  mov         dword ptr [x],3E8h
}
x = 500;
0x01001A1A  mov         dword ptr [x],1F4h
```
if문은 조건 검사에 성공할 경우 해당하는 코드 주소로 jump 하는 방식으로 작동한다.

## 2. while(true)

while문
```cpp
while (1)
{
    printf("while");
}
```
assembly
```cpp
    while (1)
0x00C011FC  mov         edx,1                 // edx에 1을 넣음
0x00C01201  test        edx,edx               // test는 2개 값을 and한 결과가 0이면 ZF=1로, 1이면 ZF=0 으로 세팅한다. 그러니까 1 & 1 = 1 이기 때문에 ZF는 항상 0이 된다.
0x00C01203  je          $LN43+37h (0C01214h)  // ZF=1일 경우 while 문 밖 주소로 jump.
    {
        printf("while");
0x00C01205  push        0C02104h              // printf
0x00C0120A  call        printf (0C01040h)     // printf
0x00C0120F  add         esp,4                 // printf
    }
0x00C01212  jmp         $LN43+1Fh (0C011FCh)  // while 문 조건 비교 주소로 jump
```
while문은 조건 검사에 실패할 경우 while문 밖의 코드 주소로 jump 한다.  
조건 검사에 성공하면 코드를 실행하고 다시 while문 처음 주소로 jump 하여 반복한다.
