---
title: CPU 캐시메모리
date: 2026-02-02 02:14:33 +0900
categories: [C++, CPU]
tags: [c++, cpu]
description: CPU 캐시메모리
---

## 요약



## 1. CPU 캐시메모리 계층구조

![캐시메모리 계층구조](/assets/img/posts/2026-02-02-CPU-cache-img-layer.webp)

CPU의 캐시메모리는 L1이 가장 빠르지만 용량이 가장 적고, L3가 가장 느리지만 용량이 가장 크다.  
그리고 그림에서 볼 수 있듯이 L3 캐시는 모든 코어가 공유하는 메모리이다.  

CPU가 어떤 변수의 값을 사용하려고 한다면 다음과 같은 절차를 거친다.
1. 먼저 레지스터에 변수값이 있는지 확인한다. 
2. 없으면 L1 Cache에서 변수값이 있는지 확인한다.
3. 없으면 L2 Cache에서 변수값이 있는지 확인한다.
4. 없으면 L3 Cache에서 변수값이 있는지 확인한다.
5. 없으면 Main Memory에서 변수값을 가져온다.
6. 만약 Main Memory에도 없으면(변수값이 있는 메모리 page가 paged out 되어서 디스크에 저장됨) 디스크에서 가져온다.


## 2. Cache Hit, Cache Miss
CPU가 변수 a의 값을 사용하려 할 때, CPU의 캐시메모리에서 a 변수 값을 찾은 경우를 cache hit 이라고 한다.
반대로 캐시메모리에서 값을 찾지 못하면 메인메모리에서 값을 가져와야 하는데 이 때는 cache miss 라고 한다.

#### Cache Hit의 속도
높은 계층의 캐시메모리에서 값을 찾을수록 성능이 좋아진다.

- L1 Cache Hit : 가장 빠른 L1에서 바로 값을 찾음. 약 4~5 CPU 클럭 소요
- L2 Cache Hit : L2에서 값을 찾음. 약 10~15 CPU 클럭 소요
- L3 Cache Hit : L3에서 값을 찾음. 약 40~60 CPU 클럭 소요
- 메인메모리에서 값을 찾음(Cache Miss) : 약 100~300 CPU 클럭 소요

## 3. Cache Hit 확률을 높이는 방법
Cache Hit이 더 자주 발생하도록 코드를 작성하면 프로그램이 더 빨라질 수 있다.

#### a. 배열 사용하기
CPU는 변수값을 사용하려고 할 때 메모리에서 해당 변수 1개만 가져오지 않는다.  
CPU는 찾는 변수가 포함된 cache line 1개를 가져온다.  
cache line은 일반적으로 64byte 이기 때문에 여러개의 변수가 포함되어 있다.

아래 vector를 순회하는 코드를 살펴보자.
```cpp
std::vector<int> vec;
for(const auto v : vec)
{
    // do something
}
```
vector는 내부적으로 값을 배열로 관리한다.   
따라서 vector의 첫 번째 int값을 CPU가 가져오면, 그 뒤의 15개의 int값도 같은 cache line에 있기 때문에 함께 가져와진다.  
그러면 vector를 순회할 때 뒤의 값들도 모두 캐시메모리에 이미 존재할 것이기 때문에 대부분 Cache Hit으로 처리된다.  
그래서 배열을 사용하면 속도가 매우 빠르다.


#### b. 자주 wrtie되는 변수와 자주 read되는 변수를 분리하기
캐시메모리 계층구조를 보면 L1 Cache와 L2 Cache는 Core끼리 서로 공유하지 않는다.  

var 변수의 값이 Core0의 L1과 Core1의 L1 둘 다에 존재한다고 하자.  
이 때 Core0에서 var의 값을 변경하면 Core1에 있는 var는 올바른 값이 아니게 된다.  
그러면 Core0는 Core1에게 이것을 알리기 위해 캐시 무효화(cache invalidation) 신호를 보내 무효화시킨다.

![캐시 무효화](/assets/img/posts/2026-02-02-CPU-cache-img-invalidation.webp)

그런데 문제는 var값 하나만 무효화되는것이 아니라, var값이 포함된 cache line 전체가 무효화 된다는 것이다.  
그러면 아래 코드를 생각해보자.

```cpp

```
